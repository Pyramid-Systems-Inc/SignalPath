@using Signalpath.Services
@using Signalpath.Models
@using System.ComponentModel

<div class="canvas-panel"
     @ondrop="HandleDrop"
     @ondragover="HandleDragOver"
     @ondragover:preventDefault
     @ondragenter="HandleDragEnter"
     @ondragleave="HandleDragLeave">
    <canvas id="schematic-canvas" class="schematic-canvas"></canvas>
</div>

@code {
    [Inject]
    private SchematicState SchematicState { get; set; } = default!;

    [Inject]
    private CanvasInterop CanvasInterop { get; set; } = default!;

    [Inject]
    private ComponentLibrary ComponentLibrary { get; set; } = default!;

    private bool isDragOver = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Initialize the canvas
            await CanvasInterop.InitializeAsync();
            
            // Subscribe to schematic state changes
            SchematicState.PropertyChanged += async (sender, e) =>
            {
                if (e.PropertyName == nameof(SchematicState.Components))
                {
                    await UpdateCanvas();
                }
                else if (e.PropertyName == nameof(SchematicState.ZoomLevel))
                {
                    await CanvasInterop.SetZoomLevelAsync(SchematicState.ZoomLevel);
                }
            };
            
            // Initial render
            await UpdateCanvas();
        }
    }

    private async Task UpdateCanvas()
    {
        await CanvasInterop.UpdateComponentsAsync(SchematicState.Components.Values);
    }

    private void HandleDragOver(DragEventArgs e)
    {
        // Allow drop
        isDragOver = true;
    }

    private void HandleDragEnter(DragEventArgs e)
    {
        isDragOver = true;
    }

    private void HandleDragLeave(DragEventArgs e)
    {
        isDragOver = false;
    }

    private async Task HandleDropAsync(DragEventArgs e)
    {
        isDragOver = false;

        try
        {
            // Get the dragged component from SchematicState
            var componentDefinition = SchematicState.DraggedComponent;
            if (componentDefinition != null)
            {
                // Calculate drop position relative to canvas
                // For now, we'll use a simple approach and improve it later
                var x = 100.0 + (SchematicState.ComponentCount * 30.0); // Stagger components horizontally
                var y = 100.0 + (SchematicState.ComponentCount * 30.0); // Stagger components vertically

                // Snap to grid (20px grid)
                const double gridSize = 20.0;
                x = Math.Round(x / gridSize) * gridSize;
                y = Math.Round(y / gridSize) * gridSize;

                // Check for overlapping components and adjust position if needed
                var adjustedPosition = FindNonOverlappingPosition(x, y, componentDefinition.Width, componentDefinition.Height);
                x = adjustedPosition.X;
                y = adjustedPosition.Y;

                // Create a new component instance
                var newComponent = new ComponentModel
                {
                    Id = Guid.NewGuid().ToString(),
                    Type = componentDefinition.Id,
                    Name = $"{componentDefinition.Name}_{SchematicState.ComponentCount + 1}",
                    X = x,
                    Y = y,
                    Width = componentDefinition.Width,
                    Height = componentDefinition.Height,
                    IsSelected = false
                };

                // Add pins to the component
                foreach (var pinDefinition in componentDefinition.Pins)
                {
                    newComponent.Pins[pinDefinition.Id] = new PinModel
                    {
                        Id = $"{newComponent.Id}_{pinDefinition.Id}",
                        Name = pinDefinition.Name,
                        RelativeX = pinDefinition.RelativeX,
                        RelativeY = pinDefinition.RelativeY,
                        AbsoluteX = x + pinDefinition.RelativeX,
                        AbsoluteY = y + pinDefinition.RelativeY,
                        Type = pinDefinition.Type,
                        ComponentId = newComponent.Id
                    };
                }

                // Add default properties
                foreach (var property in componentDefinition.DefaultProperties)
                {
                    newComponent.Properties[property.Key] = property.Value;
                }

                // Add the component to the schematic state
                SchematicState.AddComponent(newComponent);
                
                // Clear the dragged component
                SchematicState.ClearDraggedComponent();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error handling drop: {ex.Message}");
        }
    }

    private void HandleDrop(DragEventArgs e)
    {
        _ = HandleDropAsync(e);
    }

    private (double X, double Y) FindNonOverlappingPosition(double x, double y, double width, double height)
    {
        const int spacing = 10; // Minimum spacing between components
        const int maxAttempts = 10; // Maximum attempts to find a non-overlapping position
        
        for (int attempt = 0; attempt < maxAttempts; attempt++)
        {
            bool overlaps = false;
            
            // Check if this position overlaps with any existing component
            foreach (var existingComponent in SchematicState.Components.Values)
            {
                if (x < existingComponent.X + existingComponent.Width + spacing &&
                    x + width + spacing > existingComponent.X &&
                    y < existingComponent.Y + existingComponent.Height + spacing &&
                    y + height + spacing > existingComponent.Y)
                {
                    overlaps = true;
                    break;
                }
            }
            
            if (!overlaps)
            {
                return (x, y);
            }
            
            // Try next position in a spiral pattern
            if (attempt == 0)
            {
                // First attempt: try to the right
                x += width + spacing;
            }
            else if (attempt == 1)
            {
                // Second attempt: try below
                x -= width + spacing;
                y += height + spacing;
            }
            else if (attempt == 2)
            {
                // Third attempt: try to the left
                x -= width + spacing;
            }
            else if (attempt == 3)
            {
                // Fourth attempt: try above
                x += width + spacing;
                y -= height + spacing;
            }
            else
            {
                // Subsequent attempts: continue spiral pattern
                x += width + spacing;
            }
        }
        
        // If no non-overlapping position found, return the original position
        return (x, y);
    }
}