@using Signalpath.Services
@using Signalpath.Models
@using Microsoft.JSInterop
@inject IJSRuntime JSRuntime

<div class="canvas-container">
    <div class="canvas-panel"
         @ondrop="HandleDrop"
         @ondragover="HandleDragOver"
         @ondragover:preventDefault="true"
         @ondragenter="HandleDragEnter"
         @ondragleave="HandleDragLeave"
         @onmousemove="HandleMouseMove"
         @onmouseup="HandleMouseUp"
         @ref="canvasPanel">
        
        <canvas id="@canvasId" 
                class="schematic-canvas"
                @ref="canvasElement"></canvas>
        
        <!-- Custom drag preview for mouse-based dragging -->
        @if (DragDropService.IsDragging)
        {
            <div class="drag-preview" 
                 style="left: @(dragPreviewPosition.X)px; top: @(dragPreviewPosition.Y)px;">
                <div class="drag-preview-content">
                    @DragDropService.DraggedComponent?.Name
                </div>
            </div>
        }
    </div>
</div>

@code {
    [Inject]
    private CanvasInterop CanvasInterop { get; set; } = default!;
    
    [Inject]
    private SchematicState SchematicState { get; set; } = default!;
    
    [Inject]
    private IDragDropService DragDropService { get; set; } = default!;
    
    [Inject]
    private ComponentLibrary ComponentLibrary { get; set; } = default!;
    
    private ElementReference canvasElement;
    private ElementReference canvasPanel;
    private string canvasId = "schematic-canvas";
    private bool isDragOver = false;
    private (double X, double Y) dragPreviewPosition = (0, 0);

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await CanvasInterop.InitializeAsync(canvasId);
            DragDropService.DragPositionChanged += OnDragPositionChanged;
            
            // Subscribe to schematic state changes
            SchematicState.PropertyChanged += async (sender, e) =>
            {
                if (e.PropertyName == nameof(SchematicState.Components))
                {
                    await UpdateCanvas();
                }
                else if (e.PropertyName == nameof(SchematicState.ZoomLevel))
                {
                    await CanvasInterop.SetZoomLevelAsync(SchematicState.ZoomLevel);
                }
            };
            
            // Initial render
            await UpdateCanvas();
        }
    }

    private void OnDragPositionChanged((double X, double Y) position)
    {
        dragPreviewPosition = position;
        InvokeAsync(StateHasChanged);
    }

    private async Task HandleDrop(DragEventArgs e)
    {
        isDragOver = false;
        await ProcessDrop(e.ClientX, e.ClientY);
    }

    private async Task HandleMouseUp(MouseEventArgs e)
    {
        if (DragDropService.IsDragging)
        {
            await ProcessDrop(e.ClientX, e.ClientY);
            await DragDropService.EndDragAsync();
        }
    }

    private async Task HandleMouseMove(MouseEventArgs e)
    {
        if (DragDropService.IsDragging)
        {
            await DragDropService.UpdateDragPositionAsync(e.ClientX, e.ClientY);
        }
    }

    private async Task ProcessDrop(double clientX, double clientY)
    {
        try
        {
            // Get the dragged component from SchematicState or DragDropService
            var componentDefinition = SchematicState.DraggedComponent ?? DragDropService.DraggedComponent;
            if (componentDefinition != null)
            {
                // Get the actual canvas position using JavaScript interop
                var canvasRect = await CanvasInterop.GetCanvasBoundingClientRectAsync();
                
                // Calculate drop position relative to canvas
                var x = clientX - canvasRect.Left;
                var y = clientY - canvasRect.Top;

                // Adjust for zoom level
                x /= SchematicState.ZoomLevel;
                y /= SchematicState.ZoomLevel;

                // Adjust position to center the component on the drop point
                x -= componentDefinition.Width / 2;
                y -= componentDefinition.Height / 2;

                // Snap to grid (20px grid)
                const double gridSize = 20.0;
                x = Math.Round(x / gridSize) * gridSize;
                y = Math.Round(y / gridSize) * gridSize;

                // Check for overlapping components and adjust position if needed
                var adjustedPosition = FindNonOverlappingPosition(x, y, componentDefinition.Width, componentDefinition.Height);
                x = adjustedPosition.X;
                y = adjustedPosition.Y;

                // Create a new component instance
                var newComponent = new ComponentModel
                {
                    Id = Guid.NewGuid().ToString(),
                    Type = componentDefinition.Id,
                    Name = $"{componentDefinition.Name}_{SchematicState.ComponentCount + 1}",
                    X = x,
                    Y = y,
                    Width = componentDefinition.Width,
                    Height = componentDefinition.Height,
                    IsSelected = false
                };

                // Add pins to the component
                foreach (var pinDefinition in componentDefinition.Pins)
                {
                    newComponent.Pins[pinDefinition.Id] = new PinModel
                    {
                        Id = $"{newComponent.Id}_{pinDefinition.Id}",
                        Name = pinDefinition.Name,
                        RelativeX = pinDefinition.RelativeX,
                        RelativeY = pinDefinition.RelativeY,
                        AbsoluteX = x + pinDefinition.RelativeX,
                        AbsoluteY = y + pinDefinition.RelativeY,
                        Type = pinDefinition.Type,
                        ComponentId = newComponent.Id
                    };
                }

                // Add default properties
                foreach (var property in componentDefinition.DefaultProperties)
                {
                    newComponent.Properties[property.Key] = property.Value;
                }

                // Add the component to the schematic state
                SchematicState.AddComponent(newComponent);
                
                Console.WriteLine($"Component dropped at ({x:F2}, {y:F2})");
                
                // Refresh the canvas
                await UpdateCanvas();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error handling drop: {ex.Message}");
        }
        finally
        {
            // Clean up
            SchematicState.ClearDraggedComponent();
            if (DragDropService.IsDragging)
            {
                await DragDropService.EndDragAsync();
            }
        }
    }

    private async Task UpdateCanvas()
    {
        await CanvasInterop.UpdateComponentsAsync(SchematicState.Components.Values);
    }

    private void HandleDragOver(DragEventArgs e)
    {
        e.DataTransfer.DropEffect = "copy";
        isDragOver = true;
    }

    private void HandleDragEnter(DragEventArgs e)
    {
        isDragOver = true;
    }

    private void HandleDragLeave(DragEventArgs e)
    {
        isDragOver = false;
    }

    private (double X, double Y) FindNonOverlappingPosition(double x, double y, double width, double height)
    {
        const int spacing = 10; // Minimum spacing between components
        const int maxAttempts = 10; // Maximum attempts to find a non-overlapping position
        
        for (int attempt = 0; attempt < maxAttempts; attempt++)
        {
            bool overlaps = false;
            
            // Check if this position overlaps with any existing component
            foreach (var existingComponent in SchematicState.Components.Values)
            {
                if (x < existingComponent.X + existingComponent.Width + spacing &&
                    x + width + spacing > existingComponent.X &&
                    y < existingComponent.Y + existingComponent.Height + spacing &&
                    y + height + spacing > existingComponent.Y)
                {
                    overlaps = true;
                    break;
                }
            }
            
            if (!overlaps)
            {
                return (x, y);
            }
            
            // Try next position in a spiral pattern
            if (attempt == 0)
            {
                // First attempt: try to the right
                x += width + spacing;
            }
            else if (attempt == 1)
            {
                // Second attempt: try below
                x -= width + spacing;
                y += height + spacing;
            }
            else if (attempt == 2)
            {
                // Third attempt: try to the left
                x -= width + spacing;
            }
            else if (attempt == 3)
            {
                // Fourth attempt: try above
                x += width + spacing;
                y -= height + spacing;
            }
            else
            {
                // Subsequent attempts: continue spiral pattern
                x += width + spacing;
            }
        }
        
        // If no non-overlapping position found, return the original position
        return (x, y);
    }

    public void Dispose()
    {
        if (DragDropService != null)
        {
            DragDropService.DragPositionChanged -= OnDragPositionChanged;
        }
    }
}